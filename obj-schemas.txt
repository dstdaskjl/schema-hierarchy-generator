obj-schema (?x hammer2.n)
  :types
    !t0 (?x hand-tool1.n)
    !t1 (?a person1.n)
    !t2 (?b thing4.n)
    !t3 (?c (wooden.a thing4.n))
    !t4 (?d nail2.n)
    !t5 (?e handle1.n)
    !t6 (?f head29.n)

  :rigid-conds
    !r1 (?x hard3.a)
    !r2 (?f rigid1.a)
    !r3 (?f heavy1.a)     ;a high-density solid
    !r4 (?e long3.a)
      ; below are part-relationships, sizes, and perpendicularity that are
    ; possilby read off from a labeled image
    !r5 (?x have2.v ?e)       ;may need 'have-as-part.v
    !r6 (?x have2.v ?f)
    !r7 (?f mounted1-on.a ?e) ;parts-relationships (linking them to a 3D-prototype)
    !r8 (?f fixed2-to.a ?e)
    !r9 (?f perpendicular1-to.a ?e)
    !r10 (?f constituted3-of.a (k metal.n))
    !r11 ((?e constituted3-of.a (k wood.n)) or (?e constituted3-of.a (k plastic.n)))
    !r12 ((length-of.f ?e) ~= (k (1.a foot2.n)))
    !r13 (((weight-of.f ?f) > (k (15.a ounce2.n))) and.cc
        ((weight-of.f ?f) < (k (22.a ounce2.n))))

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (break5.v ((a.d (solid.a thing4.n)) ?b))))
    ?p2 (?a ((adv-a (with-instr.p ?x)) (drive8-into.v ?c ?d)))
    ?p3 (?a ((adv-a (with-instr.p ?x)) (deliver9-to.v ?b (k (impulsive3.a force2.n)))))
    ?p4 (?a ((adv-a (with-instr.p ?x)) (deliver9-to.v ((k (small.a area.n)) (of.p ?b)) (k impact1.n))))
    ?p5 (?a ((adv-a (with-instr.p ?x)) (crush4.v ((a.d rock1.n) ?l))))
    ?p6 (?a ((adv-a (with-instr.p ?x)) (knock-down2.v ?b)))
    ?p7 ((?a ((adv-a (with-instr.p ?x)) (remove1-from.v ((a.d wall.n) ?j) ((a.d tile.n) ?i)))) or
       (?a ((adv-a (with-instr.p ?x)) (remove1-from.v ((a.d floor.n) ?k) ((a.d tile.n) ?i)))))
    ?p8 (?a ((adv-a (with-instr.p ?x)) (bend3.v ((k metal1.n) ?h))))
    ?p9 (?a ((adv-a (with-instr.p ?x)) (shape2.v ((k metal1.n) ?h))))
    ?p10 (?a ((adv-a (with-instr.p ?x)) (strike.v ?b)))
    ?p11 (?a ((adv-a (with-instr.p ?x)) (pound1.v ?b)))
    ?p12 (?a swing1.v ?x)

  :shape-prototype
  hammer.obj

  :skeletal-prototype
    hammer-skeleton.obj

obj-schema (?x knife1.n)
  :types
    !t0 (?x hand-tool1.n)
    !t1 (?a person1.n)
    !t2 (?b handle1.n)
    !t3 (?c blade9.n)
    !t4 (?d edge3.n)  ;cutting edge
    !t5 (?e tip1.n)
    !t6 (?f spine.n)  ;; WN sense?

  :fluent-conds
    !f1 ((?d dull.a :c .2) xor.cc (?d sharp.a :c .5))

  :rigid-conds
    !r1 (?x dangerous1.a)
    !r2 (?x have2.v ?b)
    !r3 (?x have2.v ?c)
    !r4 (?c have2.v ?d)
    !r5 (?c have2.v ?e)
    !r6 (?c have2.v ?f)
    !r7 (?e pointed1.a)
    !r8 (?f blunt2.a)
    !r9 ((?d straight2.a) xor.cc (?d serrated1.a))
    !r10 (?d opposite1.a ?f)
    !r11 ((length-of.f ?c) ~= (k (8.a inch1.n)))

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (remove1-from.v ((a.d thing4.n) ?j) ((a.d bone1.n) ?i))))
    ?p2 (?a ((adv-a (with-instr.p ?x)) (spread10-on.v ((a.d bread1.n) ?g)
                              ((k butter1.n) ?i)))) ; butter knife #1
    ?p3 (?a ((adv-a (with-instr.p ?x)) (scratch2.v ((a.d thing4.n) ?j))))
    ?p4 (?a ((adv-a (with-instr.p ?x)) (break-down7.v ((a.d vertebrate1.n) ?k))))
    ?p5 (?a ((adv-a (with-instr.p ?x)) (butcher1.v ((a.d vertebrate1.n) ?k))))
    ?p6 (?a ((adv-a (with-instr.p ?x)) (slice3.v ((a.d thing4.n) ?j))))
    ?p7 ((?a ((adv-a (with-instr.p ?x)) (cut1.v ((a.d food2.n) ?e)))) or
      (?a ((adv-a (with-instr.p ?x)) (cut1.v ((a.d string.n) ?d))))
      (?a ((adv-a (with-instr.p ?x)) (cut1.v ((a.d flesh3.n) ?h)))))
    ?p8 ((?a ((adv-a (with-instr.p ?x)) (carve2.v ((a.d wood.n) ?c)))) or
      (?a ((adv-a (with-instr.p ?x)) (carve2.v ((a.d meat1.n) ?m))))
      (?a ((adv-a (with-instr.p ?x)) (carve2.v ((a.d vegetable1.n) ?n)))))
    ?p9 (?a ((adv-a (with-instr.p ?x)) (dice1.v ((a.d meat1.n) ?m))))
    ?p10 (?a ((adv-a (with-instr.p ?x)) (butterfly2.v ((a.d animal1.n) ?l))))
    ?p11 (?a ((adv-a (with-instr.p ?x)) (cook1.v)))
    ?p12 (?a ((adv-a (with-instr.p ?x)) (pare3.v ((a.d apple1.n) ?f))))
    ?p13 (?a ((adv-a (with-instr.p ?x)) (kill1.v ?a)))
    ?p14 (?a ((adv-a (with-instr.p ?x)) (stab1.v ?a)))
    ?p15 (?a (rest4-on.v f? (finger1-of.f ?a)))
    ?p16 (?a apply6-to.v (?x (k (downward2.a pressure.n))))

obj-schema (?x curtain1.n)
  :types
    !t0 (?x soft-goods1.n)
    !t1 (?x cloth1.n)
    !t2 (?x covering2.n)
    !t3 (?a person1.n)
    !t4 (?b eyelet1.n)
    !t5 (?c window.n)
    !t6 (?d thing4.n)

  :rigid-conds
    !r1 (?x protective1.a)
    !r2 (((length-of.f ?x) > (k (3.a foot2.n))) and.cc
       ((length-of.f ?x) < (k (11.a foot2.n))))      ;; length or height?
    !r3 ((?x sheer4.a) or.cc (?x opaque1.a))  ;; does or.cc imply something between the two?

  :static-conds
    !s1 (?x hang1-on.v ?d)
    !s2 (?x have.v ?b)

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (darken3.v (k area5.n))))
    ?p2 ((?a ((adv-a (with-instr.p ?x)) (block2.v (k heat.n)))) or
       (?a ((adv-a (with-instr.p ?x)) (block2.v (k light.n))))
       (?a ((adv-a (with-instr.p ?x)) (block2.v (k noise.n))))
       (?a ((adv-a (with-instr.p ?x)) (block2.v (k sound.n)))))
    ?p3 ((?a ((adv-a (with-instr.p ?x)) (keep-out1.v (k cold.n)))) or
       (?a ((adv-a (with-instr.p ?x)) (keep-out1.v (k heat.n)))))
    ?p4 ((?a ((adv-a (with-instr.p ?x)) (reduce1.v (k heat.n)))) or
       (?a ((adv-a (with-instr.p ?x)) (reduce1.v (k noise.n)))))
    ?p5 ((?a ((adv-a (with-instr.p ?x)) (?a blind3.v (k area5.n)))) or
       (?a ((adv-a (with-instr.p ?x)) (?a blind3.v ?d))))
    ?p6 (?a ((adv-a (with-instr.p ?x)) (hide1.v)))
    ?p7 (?a ((adv-a (with-instr.p ?x)) (obstruct3.v)))
    ?p8 (?a ((adv-a (with-instr.p ?x)) (cover1.v ?c)))
    ?p9 (?a ((adv-a (with-instr.p ?x)) (have.v (k privacy.n))))
    ?p10 (?a ((adv-a (with-instr.p ?x)) (hinder2.v (k sight.n))))

obj-schema (?x bath-mat1.n)
  :types
    !t0 (?x bath-linen1.n)
    !t2 (?b bathroom1.n)
    !t3 (?c towel1.n)
    !t4 (?d mat1.n)

  :rigid-conds
    !r1 ((?x (heavy.a ?c)) or (?x (heavy.a ?d)))
    !r2 ((?x constituted3-of.a (k wool1.n)) or
       (?x constituted3-of.a (k fiber1.n)) or
       (?x constituted3-of.a (k nylon2.n)) or
       (?x constituted3-of.a (k cotton1.n)))
    !r3 (((length-of.f ?x) > (k (17.a inch1.n))) and.cc
       ((length-of.f ?x) < (k (27.a inch1.n))))
    !r4 (((width-of.f ?x) > (k (24.a inch1.n))) and.cc
     ((width-of.f ?x) < (k (60.a inch1.n))))

  :static-conds
    !s1 (?x on.p (floor1-of.f ?b))

  :purposes
    ?p1 (?x (absorb4-from.v ((a.d (np+preds (wet1.a person1.n) (on.p ?x))) ?m) (k water.n)))
    ?p2 (?a ((adv-a (with-instr.p ?x)) (keep.v ?b dry1.a)))
    ?p3 (?a ((adv-a (with-instr.p ?x)) (prevent1.v ((a.d mold5.n) ?c))))
    ?p4 (?a ((adv-a (with-instr.p ?x)) (prevent1-from.v ?a fall1.v)))   ;; or (fall1.v ?a)
    ?p5 (?a ((adv-a (with-instr.p ?x)) (soak-up1.v (k water.n))))
    ?p6 (?a (stand1-on.v ?x))

obj-schema (?x headband1.n)
  :types
    !t0 (?x accessory1.n)
    !t2 (?x band7.n)
    !t3 (?a person1.n)
    !t4 (?b head1.n)

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (absorb4.v (k sweat1.n))))
    ?p2 (?a ((adv-a (with-instr.p ?x)) (block-out2.v (k snoring.n))))
    ?p3 (?a ((adv-a (with-instr.p ?x)) (hide1.v ((a.d bang3.n) ?d))))
    ?p4 (?a ((adv-a (with-instr.p ?x)) (keep-out3-of.v ((a.d eye1.n) ?c) (k sweat1.n))))
    ?p5 ((?a wear9.v (around.p-arg ?b)) or (?a wear9.v (over.p-arg ?b)))

obj-schema (?x hand-tool1.n)
  :types
    !t0 (?x tool1.n)
    !t1 (?x manipulable-object.n)
    !t2 (?a person1.n)
    !t3 (?b hand1.n)
    !t4 (?c thing4.n)

  :rigid-conds
    !r1 (?x portable1.a)
  
  :purposes
    ?p1 (?a hold2.v ?x)
    ?p2 (?a ((adv-a (with-instr.p ?b)) (power1.v ?x)))
    ?p3 ((?a ((adv-a (with-instr.p ?x)) (measure1.v ?c))) or.cc
       (?a ((adv-a (with-instr.p ?x)) (cut1.v ?c)))
       (?a ((adv-a (with-instr.p ?x)) (smooth1.v ?c)))
       (?a ((adv-a (with-instr.p ?x)) (shape2.v ?c)))
       (?a ((adv-a (with-instr.p ?x)) (drill1.v ?c)))
       (?a ((adv-a (with-instr.p ?x)) (fasten1.v ?c))))
    ;; is ?p3 redundant since we will have these purposes
    ;; specified in the objects, e.g. hammer, under hand-tool?

obj-schema (?x manipulable-object.n) ;; or manipulable1-object1.n?
  :types
    !t1 (?a person1.n)

  :rigid-conds
    !r1 ((?x man-made1.a) xor.cc (?x natural2.a))
    !r2 (((weight-of.f ?x) > (k (1.a gram1.n))) and.cc
       ((weight-of.f ?x) < (k (700.a gram1.n))))

  :static-conds
    !s1 (?x movable2.a)
    !s2 (?a ((adv-a (with-instr.p (one1.a ((a.d hand1.n) ?c)))) (able3.a (Ka (pick-up.v ?x)))))

obj-schema (?x animal1.n)
  :types
    !t0 (?x mammal1.n)

  :fluent-conds
    !f1 ((?x alive1.a) xor.cc (?x dead1.a))

  :rigid-conds
    !r1 (?x require1.v ((a.d nutrient1.n) ?m) (adv-a ({for}.p (to (live3.v)))))
    !r2 (?x require1.v ((a.d nutrient1.n) ?m) (adv-a ({for}.p (to (grow5.v)))))  ; and grow3.v?
    !r3 (((height-of.f ?x) > (k (1.a foot2.n))) and.cc
       ((height-of.f ?x) < (k (16.a foot2.n))))

  :static-conds
    !s1 (?x (able3.a (Ka (move1.v))))
    !s2 (?x capable1-of.a reproduction1.n)

obj-schema (?x tree1.n)
  :types
    !t0 (?x plant2.n)
    !t1 (?a trunk1.n)
    !t2 (?b branch2.n)
    !t3 (?c root1.n)
    !t4 (?d crown7.n)
    !t5 (?e leaf1.n)
    !t6 (?f sap1.n)
    !t7 (?g person1.n)

  :rigid-conds
    !r1 (?x have2.v ?a)
    !r2 (?x have2.v ?b)
    !r3 (?x have2.v ?c)
    !r4 (?x have2.v ?d)
    !r6 (?b part-of.n ?d)
    !r7 (?e part-of.n ?d)

  :static-conds
    !s1 (?a connect1.v (?c and.cc ?d))  ;; or should it go to trunk1.n?
    !s2 (?a upright3.a)
    !s3 (?f flow1-in.v ?x)
    !s4 ((?x in.p ((a.d park1.n) ?m)) or.cc
       (?x in.p ((a.d park2.n) ?n))
       (?x in.p ((a.d backyard1.n) ?o))
       (?x on.p ((a.d street1.n) ?p))
       (?x in.p ((a.d mountain1.n) ?q))
       (?x in.p ((a.d forest1.n) ?r)))

  :purposes
  ?p1 (?g ((adv-a (with-instr.p ?x)) (make6.v ((k paper1.n) ?h))))
  ?p2 (?g ((adv-a (with-instr.p ?f)) (make6.v ((a.d gum1.n) ?i))))
  ?p3 (?g ((adv-a (with-instr.p ?f)) (make6.v ((a.d syrup1.n) ?j))))
  ?p4 (((some.d bird1.n) ?k) (live1-in.v ?x))

obj-schema (?x trunk1.n)
  :types
    !t0 (?x stem2.n)
    !t1 (?a bark1.n)
    !t2 (?b person1.n)

  :rigid-conds
    !r1 (?a wooden1.a)
    !r2 (?a cover2.v ?x)
    !r3 (((width-of.f ?x) > (k (2.a inch1.n))) and.cc
     ((width-of.f ?x) < (k (40.a feet2.n))))

  :purposes
  ?p1 (?b ((adv-a (with-instr.p ?x)) (build1.v ((a.d cabin2.n) ?j))))

obj-schema (?x leaf1.n)
  :types
    !t1 (?a stem2.n)

  :fluent-conds
    !f1 ((?x green1.a) or.cc (?x yellow.1.a) (orange1.a) (red1.a))

  :rigid-conds
    !r1 (?x flat2.a)
    !r2 (?x thin1.a)

  :static-conds
    !s1 (?x attached2-to.a ?a)
    !s2 (?x acquire3-from.v (k sunlight1.n) (k energy.n))  ;; what kind of energy?

  :purposes
    ?p1 (((some.d animal1.n) ?j) eat3.v ?x)

obj-schema (?x flower1.n)
  :types
    !t0 (?x flowering-plant.n)
    !t1 (?a pollen1.n)
    !t2 (?b petal1.n)
    !t3 (?c person1.n)

  :fluent-conds
    !s1 (?x fragrant1.a :c .8)  ;; flowers lose scent and some flowers aren't fragrant

  :rigid-conds
    !r1 (?x colorful3.a)
    !r2 (?x have2.v ?a)
    !r3 ((most.d (plur ?x)) have2.v ?b)

  :static-conds
  !s1 ((?x in.p ((a.d park1.n) ?m)) or.cc
     (?x in.p ((a.d park2.n) ?n))
     (?x in.p ((a.d backyard1.n) ?o))
     (?x on.p ((a.d street1.n) ?p))
       (?x in.p ((a.d mountain1.n) ?q))
       (?x in.p ((a.d garden1.n) ?r))
       (?x in.p ((a.d grocery1.n) ?s))
       (?x in.p ((a.d vase1.n) ?t)))

  :purposes
  ?p1 (?c decorate1-with.v ?x ((a.d room1.n) ?j))
  ?p2 (?c make15.v ((a.d bouquet1.n) ?k))

obj-schema (?x flowering-plant.n)
  :types
    !t0 (?x plant2.n)
    !t1 (?a flower1.n)
    !t2 (?b stem2.n)

  :fluent-conds
    !f1 (?x bloom1.v)
    !f2 (?x have2.v ?a)   ;; repetetive after !f1?
    !f3 ((?b green1.a) or.cc (?b red1.a))

  :static-conds
    !s1 (?a attached2-to.a ?b)

obj-schema (?x grass1.n)
  :types
    !t0 (?x plant2.n)
    !t1 (?a person1.n)
    !t2 (?b animal1.n)
    !t3 (?c insect1.n)
    !t4 (?d worm1.n)

  :fluent-conds
    !f1 ((?x green1.a) or.cc (?x yellow.1.a))

  :rigid-conds
    !r1 (((height-of.f ?x) >= (k (1.a inch1.n))) and.cc
     ((height-of.f ?x) < (k (4.a inch1.n))))

  :static-conds
    !s1 ((?x grow3-in.v ((a.d lawn1.n) ?m)) or.cc
       (?x grow3-in.v ((a.d pasture1.n) ?n))
       (?x grow3-in.v ((a.d meadow1.n) ?o)))

  :purposes
    ?p1 (?a sit2-on.v ?x)
    ?p2 (?b feed6.v ?x)  ;; do we need to restrict to graminivore animals? or say "some" animals?
    ?p3 (?c live1-in.v ?x)
    ?p4 (?d live1-in.v ?x)

obj-schema (?x fruit1.n) ; mostly from Aaron Gindi's schema
  :types
    !t0 (?x manipulable-object.n)
    !t1 (?a animal1.n)
    !t2 (?b perosn1.n)
    !t3 (?c skin.n)
    !t4 (?d seed.n)
    !t5 (?e flesh.n)
    !t6 (?f plant2.n)

  :rigid-conds
    !r1 (?x part-of.n ?f)
    !r2 (?x have2.v ?e)  ;according to Wikipedia, it's not always true but we ignore
    !r3 ((dimensions-of.f ?x) = ($ dim .05 1.5 .05 1.5 .05 1.5))

  :static-conds
    !s1 ((?x have2.v (one.d ?d) xor.cc (?x have2.v (plur ?d))) ;except seedless
    !s2 (?x edible1.a) ;exceptions are poisonous or unpalatable ftuis
    !s3 (?x have2.v ?c) ;unless peeled
    !s4 ((?x in.p ((a.d market3.n) ?m) :c .3) xor.cc
       (?x in.p ((a.d home1.n) ?h) :c .2)
       (?x on.p ((a.d plant2.n) ?p) :c .5) :c .7)

  :purposes
    ?p1 (?a eat3.v ?x)
    ?p2 (?b eat1.v ?x)

obj-schema (?x vegetable.n)   ;; WN vegetable 1 or 2?
  :types
    !t0 (?x manipulable-object.n)
    !t1 (?x food2.n)
    !t2 (?x plant2.n)  ;; or part-of?
    !t3 (?a animal1.n)
    !t4 (?b person1.n)
  
  :fluent-conds
    !f1 ((?x cooked1.a) xor.cc (?x raw3.a))

  :rigid-conds
    !r1 (?x edible1.a)
    !r2 (?x require1.v ((a.d water6.n) ?e) (adv-a ({for}.p (to (survive1.v)))))

  :static-conds
    !s1 ((?x in.p ((a.d market3.n) ?m)) or.cc
       (?x in.p ((a.d kitchen1.n) ?n))
       (?x on.p ((a.d ground1.n) ?o))
       (?x under.p ((a.d ground1.n) ?p)))

  :purposes
    ?p1 (?a eat3.v ?x)
    ?p2 (?b eat1.v ?x)
    ?p3 (?b cook3.v ?x)

obj-schema (?x clothing1.n)
  :types
    !t0 (?x manipulable-object.n)
    !t1 (?a person1.n)

  :rigid-conds
    !r1 (?x constituted3-of.a fabric1.n)

  :static-conds
    !s1 (?a wear9.v ?x)
    !s2 (((a.d dog1.n) ?d) wear9.v ?x)
    !s3 ((?x in.p ((a.d closet1.n) ?m)) or.cc
       (?x in.p ((a.d drawer1.n) ?n))
       (?x in.p ((a.d store1.n) ?o)))
    ;; store or sold in these places but clothing is on someone too

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (cover1.v (body1-of.f ?a)))) ;part of a body
  ?p2 (?a ((adv-a (with-instr.p ?x)) (protect1.v (skin1-of.f ?a))))

obj-schema (?x sportswear1.n)
  :types
    !t0 (?x clothing1.n)
    !t1 (?a person1.n)
    !t2 (?b sport1.n)
    !t3 (?c activity1.n)

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (improve1.v (performance3-of.f ?a))))
    ?p2 (?a ((adv-a (with-instr.p ?x)) (protect1-from.v ((a.d injury1.n) ?m) ?x)))
    ?p3 (?a ((adv-a (with-instr.p ?x)) (feel.v comfortable.a)))
    ?p4 (?x absorb4.v (k sweat1.n))
    ?p5 (?a ((wear.v ?x) (while.ps (?a engage1-in.v ?b) or.cc (?a engage1-in.v (physical1.a ?c)))))

obj-schema (?x bottle1.n)
  :types
    !t0 (?x manipulable-object.n)
    !t1 (?a person1.n)

  :rigid-conds
    !r1 ((?a constituted3-of.a (k glass1.n)) xor.cc (?a constituted3-of.a.a (k plastic1.n)))
    !r2 (((height-of.f ?x) >= (k (5.a inch1.n))) and.cc
     ((height-of.f ?x) < (k (15.a inch1.n))))
    !r3 (((diameter-of.f ?x) > (k (2.2.a inch1.n))) and.cc
     ((diameter-of.f ?x) < (k (6.a inch1.n))))

  :static-conds
    !s1 ((?x contain2.v liquid1.n) xor.cc (?x empty1.a))

  :purposes
    ?p1 (?a (drink1-from.v ?x ((k liquid3.n) ?m)))
    ?p2 (?a (store2-in.v ?x ((k liquid3.n) ?m)))

obj-schema (?x kitchen1.n)
  :types
    !t0 (?x room1.n)
    !t1 (?a person1.n)
    !t2 (?b meal1.n
    !t3 (?c food1.n)
    !t4 (?d wall1.n)
    !t5 (?e cupboard1.n)
    !t6 (?f pantry1.n)
    !t7 (?g oven1.n)
    !t8 (?h plate4.n)
    !t9 (?i utensil1.n)
    !t10 (?j sink1.n)
    !t11 (?k refrigerator1.n)

  :rigid-conds
    !r1 (?x have2.v ?d)
    !r2 (?x have2.v ?e)
    !r3 (?x have2.v ?f)
    !r4 (?x have2.v ?j)
    !r5 (?x have2.v ?k)

  :static-conds
    !s1 ((?x in.p ((a.d institution.n)) ?m) or.cc (?x part-of.n ((a.d home2.n) ?n))) 
     ; including commercial establishment
    !s2 (?g in.p ?x)
    !s3 (?h in.p ?x)
    !s4 (?i in.p ?x)

  :purposes
  ?p1 (?a ((adv-a (in.p ?x)) (prepare2.v ?b)))
  ?p2 (?a ((adv-a (in.p ?x)) (eat1.v ?c)))

obj-schema (?x dessert1.n)
  :types
    !t0 (?x food1.n)
    !t1 (?a person1.n)
    !t2 (?b refrigerator1.n)

  :rigid-conds
    !r1 (?x sweet1.a)

  :static-conds
    !s1 (?a (store2-in.v ?b ?x))

  :purposes
    ?p1 (?a eat1.v ?x)

obj-schema (?x furniture1.n)

obj-schema (?x wardrobe1.n)
  :types
  !t0 (?x storage-space1.n)
  !t1 (?x furniture1.n)
  !t2 (?a person1.n)
  !t3 (?b clothes1.n)
  !t4 (?c bedroom1.n)
  !t5 (?d hanger2.n)
  !t6 (?e shelf1.n)
    !t7 (?f basket1.n)
    !t8 (?g drawer1.n)
    !t9 (?h dressing-room1.n)
    !t10 (?i shop1.n)
    ;; what's the horizontal bar in the hanging space of a wardrobe?

  :rigid-conds
    !r1 (?x standing1.a)

  :static-conds
    !s1 (?b in.p ?x)
    !s2 (?d in.p ?x)
    !s3 (?e part-of.n ?x)
    !s4 (?f in.p ?x)
    !s5 (?g part-of.n ?x)
    !s6 ((?x in.p ?c) or.cc (?x in.p ?h) (?x in.p ?i))
    !s7 (((height-of.f ?x) > (k (4.a foot2.n))) and.cc
     ((height-of.f ?x) < (k (8.a foot2.n))))

  :purposes
    ?p1 (?a (store2-in.v ?x ?b))
    ?p2 (?a (hang2-in.v ?x ?b))
    ?p3 (?a (organize4-in.v ?x ?b))

obj-schema (?x cupboard1.n)
  :types
    !t0 (?x storage-space1.n)
    !t1 (?x furniture1.n)
    !t2 (?a person1.n)
    !t3 (?b shelf1.n)
    !t4 (?c door1.n)
    !t5 (?d dishware1.n)
    !t6 (?e kitchen1.n)
    !t7 (?f tier5.n)
  
  :rigid-conds
    !r1 (?x have2.v ?b)
    !r2 (?x have2.v ?f)
    !r3 (?x have2.v ?c)
    !r4 (?x part-of.n ?e)

  :static-conds
    !s1 (?d in.p ?x)
    !s2 ((?c constituted3-of.a (k glass1.n)) or.cc (?c constituted3-of.a (k wood1.n)))
    !s3 (?x constituted3-of.a (k wood1.n))

  :purposes
    ?p1 (?a (store2-in.v ?x ?d))

obj-schema (?x couch1.n)
  :types
    !t0 (?x furniture1.n)
    !t1 (?a person1.n)
    !t2 (?b upholstery.n)
    !t3 (?c armrest1.n)
    !t4 (?d padding1.n)
    !t5 (?e frame9.n)
  
  :rigid-conds
    !r1 (?x have2.v ?b)
    !r2 (?x have2.v ?d)
    !r3 (?x have2.v ?e)
    !r4 (((width-of.f ?x) > (k (2.a foot2.n))) and.cc
     ((width-of.f ?x) < (k (22.a foot2.n))))

  :static-conds
    !s1 (?x have2.v ?c)
    !s2 ((?x in.p ((a.d living-room1.n) ?m)) or.cc (?x in.p ((a.d lounge2.n) ?n))) ;; outdoor patio?
    !s3 ((?e constituted3-of.a (k wood1.n)) or.cc
       (?e constituted3-of.a (k metal1.n))
       (?e constituted3-of.a (k plastic1.n)))  ; e.g. plastic lumber
    !s4 ((?b constituted3-of.a (k leather1.n)) or.cc
       (?b constituted3-of.a (k cotton1.n))
       (?b constituted3-of.a (k velvet1.n))
       (?b constituted3-of.a (k linen1.n))
       (?b constituted3-of.a (k polyester2.n)))

  :purposes
    ?p1 ((?a sit1-on.v ?x :c .8) or.cc (?a lie-on.v ?x :c .2)) ;; more than one person can sit
    ?p2 (?a (relax1.v (adv-e (on.p ?x))))  ;; what's the difference between verb-on.v and (verb (adv-e (on.p )))?

obj-schema (?x pizza1.n)
  :types
    !t0 (?x food2.n)
    !t1 (?a person1.n)
    !t2 (?b dough.n)
    !t3 (?c sauce1.n)
    !t4 (?d cheese1.n)
    !t6 (?e meat1.n)
    !t7 (?f vegetable.n)

  :rigid-conds
    !r1 (((diameter-of.f ?x) >= (k (4.a inch1.n))) and.cc ((diameter-of.f ?x) <= (k (20.a inch1.n))))
    !r2 (((height-of.f ?x) > (k (3.a millimeter1.n))) and.cc ((height-of.f ?x) <= (k (3.a inch1.n))))
    !r3 (?x have2.v ?b)
    !r4 (?a make1-of.a (k bread.n) ?b)
    !r5 (?c spreaded-on.v ?b)
    !r6 (?x have2.v ?d)

  :static-conds
    !s1 (?x have.v ?e)
    !s2 (?x have.v ?f)
    !s3 ((?c red1.a :c .82) xor.cc (?c white1.a :c .15) (?d green1.a :c .03))

  :purposes
    ?p1 (?a eat1.v ?x)

  :shape-prototype   ;; do we have pie.obj?
  pie.obj

obj-schema (?x clock1.n)
  :types
    !t0 (?x tool1.n)
    !t1 (?a person1.n)

  :rigid-conds
    !r1 (?x measure2.v (k time7.n))
    !r2 (?x show1.v (k time7.n))

obj-schema (?x analog-clock.n)
  :types
    !t0 (?x clock1.n)
    !t1 (?a number5.n)
    !t2 (?b hour-hand1.n)
    !t3 (?c minute-hand1.n)
    !t4 (?d second-hand2.n)

  :rigid-conds
    !r1 (?x have1.v ?a)
    !r2 (?a (equally2.adv-a spaced1.a))
    !r3 (?x round1.a)
    !r4 (?x have2.v ?b)
    !r5 (?x have2.v ?c)
    !r6 ((length-of.f ?b) < (length-of.f ?c))
    !r7 ((tickness-of.f ?c) > (tickness-of.f ?d))
    ;; should !r7 go to static-conds since not every clock has a second hand?

  :static-conds
    !s1 ((tickness-of.f ?b) > (tickness-of.f ?c))
    !s2 (?x have2.v ?d)
    !s3 ((?x attached2-to.a wall1.n) or.cc (?x standing1.a) (?x lean2-against.v wall1.n)

obj-shcema (?x digital-clock.n)
  :types
    !t0 (?x clock1.n)
    !t1 (?x electronic-device.n)
    !t2 (?a number5.n)

  :rigid-conds
    !r2 (?x (show1.v (k time7.n) digitally2.adv-a))

;; How do we keep multiple branches of the ontology?
;; For instance, both alalog clock and digital clock are a type of a clock
;; and the distinction is by the display method.
;; An alarm clock is also a type of a clock and this is by the functionality.
;; We don't want to say a clock has three types (analog, digital, alarm)...

obj-schema (?x cake3.n)
  :types
    !t0 (?x dessert1.n)
    !t1 (?a person1.n)
    !t2 (?b flour1.n)
    !t3 (?c sugar1.n)
    !r4 (?d egg2.n)

  :rigid-conds
    !r1 (?a (make15-of.v ?b ?x))
    !r2 (?a (make15-of.v ?c ?x))
    ;; Can we express a passive verb without making it adjective?
    ;; make15.v isn't available as adjective in WN

  :static-conds
    !s1 (?x contain1.v ?d)

  :purposes
    ?p1 (?a (eat1.v ?x (adv-e (on.p ((a.d birthday1.n) ?m)))))
  ?p2 (?a (eat1.v ?x (adv-e (on.p ((a.d wedding1.n) ?n)))))
  ;; Would this and dessert1.n schema together make an inference
  ;; that a person eats a cake when it's not someone's birthday or wedding?

  :shape-prototype
  (pie.obj xor.cc block.obj)    ;; ?

obj-schema (?x gas-station1.n)
  :types
  !t0 (?x facility1.n)
  !t1 (?a person1.n)
  !t2 (?b motor-vehicle.n)
  !t3 (?c fuel1.n)
  !t4 (?d dispenser1.n)
  
  :rigid-conds
    !r1 (?x sell (?c (for.p ?b)))
    !r2 (?x have2.v ?d)

  :static-conds
    !s1 ((?c ((k gasoline1.n) ?m)) or.cc (?c ((k diesel-oil1.n) ?n)))  ;; a verb to add? 

  :purposes
    ?p1 (?a (buy1.v ?c (adv-e (at.p ?x))))
    ?p2 (?a ((adv-a (with-instr.p ?d)) (pump-into.v ?b ?c)))

obj-schema (?x vase1.n)
  :types
    !t0 (?x container1.n)
    !t1 (?a person1.n)
    !t2 (?b flower1.n)
    !t3 (?c base19.n)
    !t4 (?d top2.n)

  :rigid-conds
    !r1 (?x have2.v ?c)
    !r2 (?x have2.v ?d)
    !r3 (?d open10.a)
    !r4 ((?x ceramic1.a) or.cc
       (?x constituted3-of.a (k glass1.n))
       (?x constituted3-of.a (k metal1.n)))

  :static-conds
    !s1 (((?x hold11.v ?b) and.cc (?b in.p ?x)) xor.cc (?x empty1.a))
    !s2 (?x breakable1.a)

  :purposes
    ?p1 (?a (keep17.v ?b (in.p-arg ?x)))
    ?p2 (?a decorate1-with.v ?x ((a.d room1.n) ?m))

  ;; need to add shape

obj-schema (?x snow.n)  ;; snow1.n + snow2.n
  :types
    !t0 (?x natural-phenomenon.n)
    !t1 (?a person1.n)
    !t2 (?b ice-crystal1.n)

  :rigid-conds
    !r1 (?x fall5.v)   ; By fall.5.v definition, snow falls from clouds
    !r2 (?x cold1.a)
    !r3 (?x (?f constituted3-of.a ?b))
    !r4 ((fresh.a ?x) soft1.a)
    !r5 ((?x melt2.v) (when.ps (it.pro get2.v warm1.a)))

  :static-conds
    !s1 ((fresh.a ?x) white1.a)
    !s2 (((old2.a ?x) white1.a) or.cc ((old2.a ?x) gray1.a))
    !s3 ((?x in.p ((k air2.n) ?n)) xor.cc (?x on.p ((a.d thing4.n) ?n)) (?x on.p ((the.d ground1.n) ?o)))

  :purposes
    ?p1 (?a (build1-out-of.v ?x ((a.d snowman1.n) ?i))) ;; what people can do with snow (not a purpose)

  :shape-prototype
  droplet.obj     ;; ?

obj-schema (?x doll.n)
  :types
    !t0 (?x toy1.n)
    !t1 (?a child1.n)
    !t2 (?b hand1.n)
    !t3 (?c leg1.n)
    !t4 (?d head1.n)

  :rigid-conds
    !r1 (((height-of.f ?x) > (k (6.a inch1.n))) and.cc
       ((height-of.f ?x) < (k (20.a inch1.n))))
    !r2 ((?x constituted3-of.a (k rubber2.n)) or.cc 
       (?x constituted3-of.a (k plastic1.n)) (?x constituted3-of.a (k wood1.n)))
    !r3 (?x have2.v (two.d (plur ?b)))
    !r4 (?x have2.v (two.d (plur ?c)))
    !r5 (?x have2.v (a.d ?d))

  :static-conds
    !s1 (?x (look-like1.v ((a.d person1.n) ?m)))

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?x)) (entertain1.v ?a)))
    ?p2 (?a (play5.v (adv-a (with.p ?x))))

obj-schema (?x table2.n)
  :types
    !t0 (?x furniture1.n)
    !t1 (?a person.1)
    !t2 (?b leg3.n)
    !t3 (?c tabletop1.n)
    !t4 (?d thing4.n)

  :rigid-conds
    !r1 ((?x have2.n (a.d ?b)) xor.cc (?x have2.n (plur ?b)))
    !r2 (?x have2.n ?c)
    !r3 (?c flat1.a)
  !r4 (?b perpendicular1-to.a ?c)
  !r5 (?b under.p ?c)
  !r6 (((height-of.f ?x) > (k (17.a inch1.n))) and.cc
       ((height-of.f ?x) < (k (31.a inch1.n))))

  :static-conds
    !s1 ((?c round1.a) or.cc (?c rectangular1.a) (?c oval1.a))

  :purposes
    ?p1 (?a (place1.v ?d (on.p-arg ?x)))

obj-schema (?x scissors.n)
  :types
  !t0 (?x hand-tool1.n)
  !t1 (?a person1.n)
  !t2 (?b blade9.n)
  !t3 (?c thing.n)
  !t4 (?d handle1.n)
  !t5 (?e handle1.n)
  !t6 (?f pivot2.n)
  
  :rigid-conds
    !r1 (?x have2.v (two.d (plur ?b)))
    !r2 (?b constituted3-of.a (k metal1.n))
    !r3 ((?b constituted3-of.a (k metal1.n)) xor.cc
       (?b constituted3-of.a (k rubber2.n)) (?b constituted3-of.a (k plastic1.n)))
    !r4 (?x have2.v (a.d ?d))   ;for thumb
  !r5 (?x have2.v (a.d ?e))   ;for the other fingers
    !r6 (?d round1.a)
    !r7 (?e oval1.a)
    !r8 ((length-of.f ?d) < (length-of.f ?e))
    !r9 (?x have2.v ?f)
    !r10 ((two.d (plur ?b)) joined2-at.a ?f)

  :purposes
    ?p1 (?a ((adv-a (with-instr.p ?d)) (cut1.v ?c)))
    ?p2 (?a (put1.v (thumb1-of.f ?a) (on.p-arg ?d)))

obj-schema (?x lawn1.n)
  :types
    !t0 (?x geographic-area1.n)
    !t1 (?a grass1.n)
    !t2 (?b soil3.n)

  :rigid-conds
    !r1 (?x covered-with.a ?a)
    !r2 (?b under.p ?a)

  :static-conds
    !s1 ((?x around.p ((a.d building1.n) ?m)) or.cc (?x in.p ((the.d park2.n) ?n)))

obj-schema (?x floor1.n)
  :types
    !t0 (?x surface1.n)
    !t1 (?a room1.n)

  :rigid-conds
    !r1 (?x part-of.n ?a)
    ;; lower surface

  :purposes
    ?p1 ((((a.d person1.n) ?m) walk1-on.v ?x) or.cc
      ((plur (feet-of.f ((a.d person1.n) ?m))) stay2-on.v ?x))

obj-schema (?x telephone-pole1.n)
  :types
    !t0 (?x column7.n)
    !t1 (?x post4.n)
    !t2 (?x supporting-structure1.n)
    !t3 (?a telephone-wire1.n)
    !t4 (?b ground1.n)

  :rigid-conds
    !r1 ((height-of.f ?x) >= (k (35.a foot2.n)))
    !r2 (?x perpendicular1-to.a ?b)
    !r3 ((?x constituted3-of.a (k wood1.n)) or (?x constituted3-of.a (k metal1.n))
       (?x constituted3-of.a (k concrete1.n)))

  :purposes
    ?p1 (?x support4.v ?a)

  :shape-prototype
  cylinder.obj

obj-schema (?x pet1.n)
  :types
    !t0 (?x animal1.n)
    !t1 (?a owner2.n)

  :rigid-conds
    !r1 (?x domestic4.a)

  :static-conds
    !r1 (?x have7.v ?a)

  :purposes
    ?p1 (?x company1.v ?a)

obj-schema (?x beach1.n)
  :types
    !t0 (?x geological-formation1.n)
    !t1 (?x location1.n)
    !t2 (?a water2.n)
    !t3 (?b sand1.n)
    !t4 (?c rock1.n)
    !t5 (?d seashell1.n)
  
  :rigid-conds
    !r1 (?a at.p ?x)
    !r2 (?b at.p ?x)
    !r3 (?c at.p ?x)
    !r4 (?d at.p ?x)

  :static-conds
    !r1 (?x near.p (the.d coast1.n))

  :purposes
    ?p1 (((a.d person1.n) ?m) relax1-at.v ?x)

obj-schema (?x door1.n)
  :types
    !t0 (?x barrier1.n)
    !t1 (?a doorknob1.n)
    !t2 (?b door2.n)

  :rigid-conds
    !r1 (?x at.v ?b)
    !r2 ((?x (attached2-to.v ?b (by.p-arg (plur hinge1.n)))) xor.cc (?x slide3.v))
      ;; passive attached2-to.v

  :static-conds
    !s1 (?x have2.v ?a)

  :purposes
    ?p1 ((a.d (closed3.a ?x)) provide.v security1.n)
    ?p2 ((((a.d person1.n) ?m) (enter1.v (a.d enclosure1.n) (by.p-arg (ka open1.v ?x)))) or.cc
       (((a.d person1.n) ?m) (leave5.v (a.d enclosure1.n) (by.p-arg (ka open1.v ?x)))))

obj-schema (?x door2.n)
  :types
    !t0 (?x entrance1.n)
    !t1 (?a enclosure1.n)

  :rigid-conds
    !r1 (?x part-of.n ?a)   ;; does this imply every enclosed area has an entrance?

  :purposes
    ?p1 ((((a.d object1.n)) (enter1.v ?a (through.p-arg ?x))) or.cc
       (((a.d object1.n)) (leave5.v ?a (through.p-arg ?x))))   ; objects like person, dog, car

obj-schema (?x toothbrush1.n)
  :types
    !t0 (?x implement1.n)
    !t1 (?x manipulable-object.n)
    !t2 (?a handle1.n)
    !t3 (?b head7.n)
    !t4 (?c brush2.n)
  
  :rigid-conds
    !r1 (?x have2.v ?a)
    !r2 (?x have2.v ?b)
    !r3 (?b have2.v ?c)
    !r4 (?c constituted3-of.a (plur bristle1.n))
    !r5 ((length-of.f ?x) ~= (k (7.a inch1.n)))

  :purposes
    ?p1 ((((a.d person1.n) ?m) ((adv-a (with-instr.p ?x)) (clean1.v (plur tooth1.n)))) or.cc
       (((a.d person1.n) ?m) ((adv-a (with-instr.p ?x)) (clean1.v (plur gum2.n))))
       (((a.d person1.n) ?m) ((adv-a (with-instr.p ?x)) (clean1.v (plur tongue1.n)))))

obj-schema (?x mattress1.n)
  :types
    !t0 (?x furniture1.n)
    !t1 (?a spring2.n)
    !t2 (?b pad4.n)

  :rigid-conds
    !r1 (((width-of.f ?x) > (k (2.a foot2.n))) and.cc
         ((width-of.f ?x) < (k (6.a foot2.n))))
    !r2 (((depth-of.f ?x) > (k (4.a foot2.n))) and.cc
         ((depth-of.f ?x) < (k (8.a foot2.n))))
    !r3 ((height-of.f ?x) < (k (2.a foot2.n)))
    !r4 ((top-of.f ?x) have2.v ?b)

  :static-conds
    !r1 (?x have2.v ?a)

;; :shape-prototype
;;   rectangular box

obj-schema (?x bed1.n)
  :types
    !t0 (?x furniture1.n)
    !t1 (?a mattress1.n)
    !t2 (?b sheet3.n)
    !t3 (?c bedframe1.n)
    !t5 (?d headboard1.n)

  :rigid-conds
    !r1 (?a part-of.n ?x)
    !r2 (?b part-of.n ?x)
  
  :static-conds
    !s1 (?c part-of.n ?x)
    !s2 (?d part-of.n ?x)
    !s3 (?e part-of.n ?x)

  :purposes
    ?p1 (((a.d person1.n) ?m) (lie2-down.v (adv-e (on.p ?x))))
    ;; is ?m variable bound within each clause? each purpose?
    ?p2 (((a.d person1.n) ?m) (sleep1.v (adv-e (on.p ?x))))

obj-schema (?x bedframe1.n)
  :types
    !t0 (?x furniture1.n)
    
  :rigid-conds
    !r1 ((?x constituted3-of.a (k metal1.n)) or.cc (?x constituted3-of.a (k wood1.n)))

  :purposes
    ?p1 (?x support4.v ((a.d mattress1.n) ?m))
    ?p2 (?x secure2.v ((a.d mattress1.n) ?m))
    ?p3 (?x (raise2.v ((a.d mattress1.n) ?m) (adv-e (off.p ((the.d ground1.n) ?n)))))

obj-schema (?x chair1.n)
  :types
    !t0 (?x furniture1.n)
    !t1 (?a back8.n)
    !t2 (?b seat4.n)
    !t3 (?c leg3.n)

  :rigid-conds
    !r1 (?x have2.v ?b)
    !r2 (?x have2.v (plur ?c))

  :static-conds
    !s1 (?x have2.v ?a)
    !s2 (?a perpendicular1-to.a ?b)

  :purposes
    ?p1 (((a.d person1.n) ?m) (sit3.v (on.p-arg ?x))) ;; sit on ?b of ?x

obj-schema (?x shelf1.n)
  :types
    !t0 (?x storage.n)
    !t1 (?a surface.n)

  :rigid-conds
    !r1 (?x have2.v ?a)

  :static-conds
    !s1 (?a (fixed3-to.a ((a.d thing4.n) ?n) horizontally1.adv))  ;;fixed2 or fixed3?

  :purposes
    ?p1 (((a.d person1.n) ?m) (put1.v ((a.d thing4.n) ?n) (on.p-arg ?x)))






obj-schema (?x rainbow1.n)
  :types
    !t0 (?x natural-phenomenon.n)

obj-schema (?x window.n)
  :types
    !t0 (?x structure1.n)
    !t1 (?a frame.n)
    !t2 (?b windowpane1.n)
    !t3 (?c artifact1.n)   ; e.g. building, room, vehicle

  :rigid-conds
    !r1 (?x part-of.n ?c)
  !r3 (?b constituted3-of.a (k glass.n))

  :purposes
    ?p1 (?x allow1.v ((k light1.n) ?m))



